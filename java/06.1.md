#### jvm运行时数据区域包括哪些

* 线程共享区域
    - 方法区
    - 堆
* 线程私有区域
    - 虚拟机栈
    - 本地方法栈
    - 程序计数器

1. 程序技术器是一块较小的内存空间，作用于记录当前线程所执行的字节码的行号指示器，通过程序计数器来实现下一条执行的字节码指令．由于Java虚拟机是通过多线程轮流切换并分配处理器时间来实现的，在任何时候一个处理器只会执行一条线程中的指令，所以每个线程都是独立的程序计数器，各个线程之间互不影响，独立存储，恢复到当前执行的位置

2. 虚拟机栈生命周期与线程一样，描述的是Java方法执行的内存模型，每个方法执行的时候都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息，方法的调用就对应的一个栈帧在虚拟机栈中的入栈与出栈．局部变量表存储的是编译期间各种基本数据类型，对象的引用不等同于对象本身，它可能指向的是引用这个对象的指针，也可能是指向这个对象的句柄或者是这个对象的相关位置

3. 本地方法栈与虚拟机栈的作用相似，唯一不同的是虚拟机栈提供的是Java字节码服务，而本地方法栈提供的是本地方法的服务

4. 堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域．在虚拟机启动时候创建，唯一的目的是存放对象的实例，几乎所有的对象都放在堆里面．（GC回收器主要管理的）

5. 方法区与Java堆一样是各个线程共享的区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据．

6. 运行时常量池是方法区的一部分用于存放编译期生成的各种字面量和符号的引用，将在类加载之后添加到运行时常量池（运行期间产生的新常量也可能放进去）

7. 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域．它可以使用Native函数库直接分配堆外的内存，然后通过Java堆中的DirectByBuffer对象作为这块区域的引用


#### 对象的创建

```text
   当虚拟机遇到一条new指令的时候，首先去检查这个指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过．如果没有，那必须先执行类加载的过程．
   
   在虚拟机确认类检查通过后，接下来虚拟机将要为新生的对象分配内存（把Java堆的一块确定大小的内存划分出来）．如果Java堆中内存是绝对规整的，就把已用内存放在一边，未用内存放在一边，使用指针作为分界点指示器，内存分配就只需要把指针向空闲的一边移动与对象相等大小的距离，这种分配方式就叫指针碰撞．如果Java中内存不是规整的而是相互交错的，虚拟机就必须维护一个列表，来记录内存的使用情况，在分配的时候就在列表中找一个足够大小的内存分配并记录在列表中，这种分配方式就称为空闲列表．在分配完对象之后，虚拟机需要将分配到的内存空间都初始化为零，然后在对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息．这些信息都存储在对象头之中.
```